# Практична робота №5
Темою практичної роботи №5 помилки роботи з пам'яттю в Linux та засоби їх усунення.
## Завдання 
### Умова
Напишіть програму, яка демонструє використання змінної до її ініціалізації, але так, щоб на більшості систем це не викликало миттєвий крах.
### Рішення
Спочатку я вирішила написати простий [код](https://github.com/AnastasiiaVdovina/Practice5/blob/main/task.c), , який відповідатиме умові задачі. 
Структура коду досить проста: ми створюємо неініціалізовану змінну цілочисельного типу в статичній пам'яті, виводимо її значення, далі виконуємо з нею просту математичну операцію, і виводимо її результат. Аналогічно я повторила це, але вже виділяючи динамічно пам'ять на кучі, а не в стеку. Я вирішила також попрацювати з динамічною пам'яттю з причини того, що коли я просто створювала змінну на стеку, то значення яке в ній зберігалось було нулем, а я хотіла побачити там сміття, тож вирішила, що з динамічною пам'яттю вірогідність побачити "сміття" збільшиться. Але скомпілювавши і запустивши це, я отримала наступний результат:

![image](https://github.com/user-attachments/assets/3a40f33e-5ff3-47a7-9519-9496587253f4)

По-перше, варто зазначити, що компілятор попереджає нас про такі нерозумні рішення, як використання неініціалізованих змінних, але в цьому була моя задача.
Як результат, ми бачимо, що мені щастить, і ні в стеку, ні на купі у мене не зберігається сміття.
Цей результат видався мені якимось нудним, тож я вирішила поекспериментувати і запустити цей код додатково на Windows.
Ось що я отримала:

![image](https://github.com/user-attachments/assets/8d5bd410-800c-42a4-8a6d-2eb1006f204c)

Після такого результату, який, очевидно, мене не влаштував, я вирішила також скопмілювати код в онлайн-компіляторі. Результат був наступним:

![image](https://github.com/user-attachments/assets/3049bc14-60eb-41ba-a953-f11c2b4d3470)

Тут ми вже бачимо "сміття" в стеку. Це вже щось.

Як підсумок по цьому, можна сказати, що у моїй програмі неініціалізовані змінні, однак при цьому:
- Немає звернень до забороненої пам’яті
- Немає порушення доступу (segmentation fault)
  
Тобто неініціалізовані змінні не гарантують краху програми, але їх використання призводить до невизначеної поведінки (undefined behavior).

Було прийнято вольове рішення піти від зворотнього: що ж тоді призведе до краху?

Додатково я написала [тестовий випадок](https://github.com/AnastasiiaVdovina/Practice5/blob/main/test.c). Що демонструє одразу 2 випадки, коли програма миттєво буде крашитись:
1. Використання невизначеного вказівника
2. Звільнення пам’яті, яка не була виділена (або вже була звільнена)
Варто зазначити, що досягти миттєвого краху більш можливо при роботі саме з динамічною пам'яттю.

![image](https://github.com/user-attachments/assets/4ac5cd72-3d41-49fa-9990-b48625d0ca8e)

В обох випадках ми отримаємо segmentation fault.
Чому так відбувається?
Коли ми ініціалізуємо вказівник, він містить випадкову адресу. Спроба звернення до неї — незаконний доступ до пам’яті.

## Компіляція та запуск
Команда компіляції програми:
```
gcc -Wall task.c -o task
```

Запуск:
```
./task
```
